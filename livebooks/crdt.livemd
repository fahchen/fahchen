# Introductions to Conflict-free Replicated Data Type (CRDT)

## ä¸€ä¸ªé—®é¢˜

æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬å°†è¦æ‰“é€ ä¸€ä¸ªè·¨è¡Œæ˜Ÿçš„è§†é¢‘æµæœåŠ¡ã€‚æ¯å½“ç”¨æˆ·ä¸Šä¼ è§†é¢‘æ—¶ï¼Œæˆ‘ä»¬éƒ½ä¼šåœ¨ä¸åŒæ˜Ÿçƒçš„ä¸åŒæ•°æ®ä¸­å¿ƒå¤åˆ¶è§†é¢‘ï¼Œä»¥ä¿æŒè‰¯å¥½çš„ååé‡å’Œå»¶è¿Ÿï¼Œä»è€Œè·å¾—æ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¸Œæœ›å‘ç”¨æˆ·æ˜¾ç¤ºè¯¥è§†é¢‘çš„æµè§ˆé‡ã€‚

è§†é¢‘ä¸Šä¼ æ˜¯ä¸»ä»å¤åˆ¶çš„å¥½ä¾‹å­ã€‚ç„¶è€Œï¼Œå¯¹äºç»Ÿè®¡æµè§ˆè¿™ä¸ªåŠŸèƒ½æ¥è¯´ï¼Œäº‹æƒ…å¯èƒ½ä¼šå˜å¾—å¤æ‚ã€‚ç”±äºæ•´ä¸ªæ˜Ÿçƒä¸Šæœ‰å¾ˆå¤šå¹¶å‘ç”¨æˆ·ï¼Œå¹¶ä¸”å…·æœ‰å†™çš„é¢‘æ¬¡é«˜ï¼ˆwrite-heavyï¼‰çš„ç‰¹ç‚¹ï¼Œå› æ­¤ä½¿ç”¨ä¸€ä¸ªè®¡æ•°å™¨ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´ç‰¹åˆ«å—æ¬¢è¿çš„è§†é¢‘é˜»å¡ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿä¸éœ€è¦äº‹åŠ¡ï¼Œå› ä¸ºé—®é¢˜çš„æ€§è´¨å…è®¸æˆ‘ä»¬æ”¾æ¾å¼ºä¸€è‡´æ€§çš„è¦æ±‚ï¼Œä»è€Œæé«˜åº”ç”¨ç¨‹åºçš„å¯ç”¨æ€§ã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°ç°æœ‰è§£å†³æ–¹æ¡ˆéƒ½åŸºäºå¯¹èµ„æºçš„è¿›è¡Œæ’ä»–æ€§å†™æ“ä½œã€‚

## CRDT æ˜¯ä»€ä¹ˆ

åœ¨å¾ˆå¤šç³»ç»Ÿä¸­ï¼Œæ•°æ®è¢«å­˜å‚¨åœ¨ä¸åŒçš„å‰¯æœ¬ä¸­ï¼Œæ¯”å¦‚ï¼š

1. è·¨ç»ˆç«¯æ•°æ®åŒæ­¥ï¼Œå¦‚ï¼šè´­ç‰©è½¯ä»¶åŒæ­¥è´­ç‰©è½¦
2. åˆ†å¸ƒå¼æ•°æ®åº“ï¼Œå¦‚
3. åä½œè½¯ä»¶ï¼Œå¦‚ï¼š Google Doc, Notion, Figma ç­‰

åœ¨ä»¥ä¸Šä½¿ç”¨ç³»ç»Ÿä¸­éƒ½å­˜åœ¨ä¸€ä¸ªå…±åŒçš„é—®é¢˜éœ€è¦è§£å†³ï¼Œ**å¦‚ä½•åœ¨ä¸åŒçš„å‰¯æœ¬ä¸Šå¹¶å‘åœ°ä¿®æ”¹æ•°æ®**ã€‚

é€šå¸¸æ¥è®²æœ‰ä¸¤ç§æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

1. å¼ºä¸€è‡´æ€§çš„: Strongly consistent replication
2. ä¹è§‚çš„: **Optimistic replication** (CRDT è¦è§£å†³çš„)

**CRDT å®šä¹‰:**

A **Conflict-free Replicated Data Type (CRDT)** is a data structure that simplifies distributed data storage systems and multi-user applications.

æ— å†²çªæ˜¯ä¸€ä¸ªæ¨¡ç³Šçš„æè¿°ï¼Œæˆ‘ä»¬å°è¯•ç»™å®ƒä¸€ä¸ªå®šä¹‰ï¼šå½“æˆ‘ä»¬è¦æ“ä½œä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œä¸éœ€è¦è·å–ä¸€ä¸ªæ’ä»–é”å°±èƒ½è¿›è¡Œå†™æ“ä½œï¼Œå¹¶ä¸”èƒ½å¤Ÿæ£€æµ‹å¹¶å‘æ›´æ–°å¹¶æ‰§è¡Œç¡®å®šæ€§çš„è‡ªåŠ¨å†²çªè§£å†³ã€‚è¿™å¹¶ä¸æ„å‘³ç€å†²çªæ°¸è¿œä¸ä¼šå‘ç”Ÿï¼Œè€Œæ˜¯æˆ‘ä»¬å§‹ç»ˆèƒ½å¤Ÿæ ¹æ®æ•°æ®ç»“æ„æœ¬èº«åŒ…å«çš„ä¿¡æ¯æ¥ç»™å‡ºç¡®å®šçš„ç»“æœã€‚

1. ä»»ä½•å‰¯æœ¬éƒ½èƒ½åœ¨ä¸å¯¹é½ï¼ˆæ ¡å‡†ï¼‰å…¶ä»–å‰¯æœ¬çš„æƒ…å†µä¸‹è¿›è¡Œç¼–è¾‘
2. ä»»ä¸€ä¸¤ä¸ªå‰¯æœ¬æ¥æ”¶åˆ°åŒæ ·çš„æ›´æ–°æ—¶ï¼Œå®ƒä»¬çš„çŠ¶æ€èƒ½é€šè¿‡åˆå¹¶è¾¾åˆ°ä¸€è‡´

## Types

1. **State-based**
2. Operation-based
3. Delta-based

### State-based CRDTs

åŸºç¡€çš„ç±»å‹æœ‰ `Counter`, `Register` åŠ `Set`ã€‚å®ƒä»¬éƒ½æ¶‰åŠä¸€ä¸ªæœ€é‡è¦çš„æ–¹æ³• â€”â€” `MERGE`ã€‚

ä¸‰ä¸ªé‡è¦ç‰¹æ€§ï¼š

1. ç»“åˆæ€§
   Associativity states that the parentheses donâ€™t matter. Formally speaking, x âˆ¨ (y âˆ¨ z) = (x âˆ¨ y) âˆ¨ z must hold (mathematicians usually write âˆ¨ for join). You know associativity from adding and multiplying numbers.

2. äº¤æ¢æ€§
   Commutativity states that the order of joining doesnâ€™t matter. Formally, x âˆ¨ y must be equal to y âˆ¨ x. Adding and multiplying numbers is also commutative.

3. å¹‚ç­‰
   Idempotence states that joining a value to itself always returns the value itself. This is not something that numbers typically do. Unless you consider taking the maximum of two numbers.

ä¸¤ç§æ”¯æŒä»¥ä¸Šç‰¹æ€§çš„æ•°æ®ç»“æ„ï¼š

* union of two sets
* maximum of two values

### Property based testing

```elixir
Mix.install([
  {:propcheck, "~> 1.4"}
])
```

```elixir
use PropCheck

quickcheck(
  forall str <- utf8() do
    # IO.inspect(str)
    equals(str, str)
  end
)
```

```elixir
alias MapSet, as: Set
use PropCheck

# assoc ç»“åˆ
quickcheck(
  forall [a_list, b_list, c_list] <- [list(), list(), list()] do
    a = Set.new(a_list)
    b = Set.new(b_list)
    c = Set.new(c_list)

    # (( a âˆª b ) âˆª c) = (a âˆª ( b âˆª c ))
    ab_c = Set.union(Set.union(a, b), c)
    a_bc = Set.union(a, Set.union(b, c))

    equals(ab_c, a_bc)
  end
)

# commute äº¤æ¢
quickcheck(
  forall [a_list, b_list] <- [list(), list()] do
    a = Set.new(a_list)
    b = Set.new(b_list)

    # ( a âˆª b ) = ( b âˆª a )
    ab = Set.union(a, b)
    ba = Set.union(b, a)

    equals(ab, ba)
  end
)

# idem å¹‚ç­‰
# ( a ) = (a âˆª a)
quickcheck(
  forall l <- list() do
    a = Set.new(l)
    b = Set.union(a, a)

    equals(a, b)
  end
)
```

### Growing-only Counter(GCounter)

åªå…è®¸å¢åŠ çš„è®¡æ•°å™¨ï¼Œå¯ä»¥è§£å†³æˆ‘ä»¬æœ€å¼€å§‹æå‡ºçš„é‚£ä¸ªé—®é¢˜ã€‚

```elixir
defmodule Counter do
  use GenServer
  defstruct [:id, :value, :others]

  @impl true
  def init(id) do
    {:ok, %__MODULE__{id: id, value: 0, others: %{}}}
  end

  @impl true
  def handle_call(:increment, _from, %__MODULE__{} = state) do
    %__MODULE__{
      id: id,
      value: value
    } = state

    value = value + 1

    IO.puts("Counter(#{id}) increments one to #{value}")

    {:reply, value, %{state | value: value}}
  end

  @impl true
  def handle_call({:sync, {id, value}}, _from, state) do
    %__MODULE__{others: others} = state

    IO.puts("Counter(#{state.id}) syncs from Counter(#{id}) with value #{value}")

    others = Map.put(others, id, value)

    {:reply, :ok, %{state | others: others}}
  end

  @impl true
  def handle_call(:sum, _from, state) do
    %__MODULE__{
      id: id,
      value: value,
      others: others
    } = state

    sum =
      Enum.reduce(others, value, fn {_replica_id, replica_value}, acc ->
        acc + replica_value
      end)

    IO.puts("Sum on counter(#{id}) is #{sum}")

    {:reply, sum, state}
  end
end
```

```elixir
{:ok, counter1} = GenServer.start_link(Counter, 1)
{:ok, counter2} = GenServer.start_link(Counter, 2)

# increment on counter1
value = GenServer.call(counter1, :increment)

GenServer.call(counter2, :sum)
GenServer.call(counter2, {:sync, {1, value}})
GenServer.call(counter2, :sum)

# increment on counter2
value = GenServer.call(counter2, :increment)
GenServer.call(counter1, :sum)
GenServer.call(counter2, :sum)
GenServer.call(counter1, {:sync, {2, value}})
GenServer.call(counter1, :sum)
GenServer.call(counter2, :sum)
```

### Increment/decrement Counter

åŒæ—¶æ”¯æŒå¢åŠ å’Œå‡å°‘æ“ä½œï¼Œå†…éƒ¨ä½¿ç”¨ä¸¤ä¸ª GCounter æ¥å®ç°ï¼Œä¸€ä¸ªç”¨äºç»´æŠ¤å¢åŠ ï¼Œå¦ä¸€ä¸ªç”¨äºç»´æŠ¤å‡å°‘ã€‚

### Vector Clock(çŸ¢é‡æ—¶é’Ÿ)

åœ¨å¤§éƒ¨åˆ†ç³»ç»Ÿé‡Œé¢ï¼Œæˆ‘ä»¬ä½¿ç”¨ timestamp æ¥å®šä¹‰ causality (a happened-before relationship)ï¼Œ
ä½†æ˜¯è¿™ä¸ªåœ¨ä¸€ä¸ªåˆ†å¸ƒå¼çš„ç³»ç»Ÿé‡Œé¢å­˜åœ¨ä¸€äº›é—®é¢˜ï¼š

1. å‰¯æœ¬å¯èƒ½ä½äºä¸åŒçš„æ•°æ®ä¸­å¿ƒï¼Œå¯¼è‡´[æ—¶é’Ÿåç§»](https://zh.wikipedia.org/wiki/æ—¶é’Ÿåç§»)
2. timestamp æ— æ³•å‘ŠçŸ¥æˆ‘ä»¬æ¥è‡ªä¸åŒå‰¯æœ¬é—´çš„å…ˆåå…³ç³»ï¼ˆç³»ç»Ÿç®¡ç†å‘˜ç”šè‡³å¯ä»¥æ‰‹åŠ¨ä¿®æ”¹ç³»ç»Ÿæ—¶é—´ï¼‰

ä»¥ä¸Šé—®é¢˜å¯ä»¥ä½¿ç”¨çŸ¢é‡æ—¶é’Ÿæ¥è§£å†³ï¼Œç”±æ¯ä¸ªå‰¯æœ¬ç‰¹æœ‰çš„å•è°ƒé€’å¢è¡¨ç¤ºï¼Œå’Œä¸Šé¢è®²çš„ Gcounter ç±»ä¼¼ã€‚

å¦‚ä½•å¯¹æ¯”ä¸¤ä¸ªæ—¶é’Ÿï¼š

1. å¦‚æœå¯¹åº”å‰¯æœ¬çš„æ‰€æœ‰å€¼éƒ½ç›¸ç­‰ï¼Œåˆ™æ—¶é’Ÿç›¸ç­‰
2. å¦‚æœå·¦ä¾§çš„æ‰€æœ‰å€¼éƒ½ä½äºæˆ–ç­‰äºå³ä¾§çš„å¯¹åº”å€¼ï¼Œåˆ™å·¦ä¾§å°äºå³ä¾§
3. å¦‚æœå·¦ä¾§çš„æ‰€æœ‰å€¼éƒ½å¤§äºæˆ–ç­‰äºå³ä¾§çš„å¯¹åº”å€¼ï¼Œåˆ™å·¦ä¾§å¤§äºå³ä¾§
4. å…¶ä»–ç»“æœéƒ½æ„å‘³ç€æˆ‘ä»¬æ£€æµ‹åˆ°å¹¶å‘æ›´æ–°

![Vector Clock](https://upload.wikimedia.org/wikipedia/commons/5/55/Vector_Clock.svg)

```elixir
defmodule Clock do
  @moduledoc false

  @type replica_name :: term
  @type clock :: pos_integer()
  @type context :: %{replica_name => clock}
  @type replica_clock :: {replica_name, context}

  @doc """
  Returns a list of replicas from a list of contexts.
  """
  @spec clockset_replicas([clock]) :: [State.name()]
  def clockset_replicas(clockset) do
    for {replica, _} <- clockset, do: replica
  end

  @doc """
  Adds a replicas context to a clockset, keeping only dominate contexts.
  """
  @spec append_clock([replica_clock], replica_clock) :: [replica_clock]
  def append_clock(clockset, {_, clock}) when map_size(clock) == 0, do: clockset

  def append_clock(clockset, {node, clock}) do
    big_clock = combine_clocks(clockset)

    cond do
      dominates?(clock, big_clock) -> [{node, clock}]
      dominates?(big_clock, clock) -> clockset
      true -> filter_clocks(clockset, {node, clock})
    end
  end

  @doc """
  Checks if one clock causally dominates the other for all replicas.
  """
  @spec dominates?(context, context) :: boolean
  def dominates?(c1, c2) when map_size(c1) < map_size(c2), do: false

  def dominates?(c1, c2) do
    Enum.reduce_while(c2, true, fn {replica, clock}, true ->
      if Map.get(c1, replica, 0) >= clock do
        {:cont, true}
      else
        {:halt, false}
      end
    end)
  end

  @doc """
  Checks if one clock causally dominates the other for their shared replicas.
  """
  def dominates_or_equal?(c1, c2) when c1 == %{} and c2 == %{}, do: true
  def dominates_or_equal?(c1, _c2) when c1 == %{}, do: false

  def dominates_or_equal?(c1, c2) do
    Enum.reduce_while(c1, true, fn {replica, clock}, true ->
      if clock >= Map.get(c2, replica, 0) do
        {:cont, true}
      else
        {:halt, false}
      end
    end)
  end

  @doc """
  Returns the upper bound causal context of two clocks.
  """
  def upperbound(c1, c2) do
    Map.merge(c1, c2, fn _, v1, v2 -> max(v1, v2) end)
  end

  @doc """
  Returns the lower bound causal context of two clocks.
  """
  def lowerbound(c1, c2) do
    Map.merge(c1, c2, fn _, v1, v2 -> min(v1, v2) end)
  end

  defp filter_clocks(clockset, {node, clock}) do
    clockset
    |> Enum.reduce({[], false}, fn {node2, clock2}, {set, insert} ->
      if dominates?(clock, clock2) do
        {set, true}
      else
        {[{node2, clock2} | set], insert || !dominates?(clock2, clock)}
      end
    end)
    |> case do
      {new_clockset, true} -> [{node, clock} | new_clockset]
      {new_clockset, false} -> new_clockset
    end
  end

  defp combine_clocks(clockset) do
    clockset
    |> Enum.map(fn {_, clocks} -> clocks end)
    |> Enum.reduce(%{}, &upperbound(&1, &2))
  end
end
```

```elixir
ExUnit.start(autorun: false)

defmodule ClockTest do
  use ExUnit.Case

  test "dominates?" do
    clock1 = %{a: 1, b: 2, c: 3}
    clock2 = %{b: 2, c: 3, d: 1}
    clock3 = %{a: 1, b: 2}
    assert Clock.dominates?(clock1, clock3)
    refute Clock.dominates?(clock3, clock1)
    refute Clock.dominates?(clock1, clock2)
    assert Clock.dominates?(clock1, clock1)
  end

  # å…ˆçœ‹ä¸‹æ–¹çš„ Lattices çš„å®šä¹‰

  test "upperbound" do
    assert Clock.upperbound(%{a: 1, b: 2, c: 2}, %{a: 3, b: 1, d: 2}) ==
             %{a: 3, b: 2, c: 2, d: 2}

    assert Clock.upperbound(%{}, %{a: 3, b: 1, d: 2}) == %{a: 3, b: 1, d: 2}
    assert Clock.upperbound(%{a: 3, b: 1, d: 2}, %{}) == %{a: 3, b: 1, d: 2}
    assert Clock.upperbound(%{a: 3, b: 1, d: 2}, %{a: 3, b: 1, d: 2}) == %{a: 3, b: 1, d: 2}
  end

  test "lowerbound" do
    assert Clock.lowerbound(%{a: 1, b: 2, c: 2}, %{a: 3, b: 1, d: 2}) ==
             %{a: 1, b: 1, c: 2, d: 2}

    assert Clock.lowerbound(%{}, %{a: 3, b: 1, d: 2}) == %{a: 3, b: 1, d: 2}
    assert Clock.lowerbound(%{a: 3, b: 1, d: 2}, %{}) == %{a: 3, b: 1, d: 2}
  end

  test "test the set trims" do
    clock1 = {:a, %{a: 1, b: 2, c: 3}}
    clock2 = {:b, %{b: 2, c: 3, d: 1}}
    clock3 = {:c, %{a: 1, b: 2}}
    assert [clock2, clock3] == Clock.append_clock([clock2, clock3], clock1) |> Enum.sort()
    assert [clock1, clock2] == Clock.append_clock([clock1, clock2], clock3) |> Enum.sort()
    assert [clock1, clock2] == Clock.append_clock([clock1, clock2], clock1) |> Enum.sort()
    assert [clock1, clock2] == Clock.append_clock([clock1, clock2], clock2) |> Enum.sort()
    assert [clock1, clock2, clock3] == Clock.append_clock([clock1, clock3], clock2) |> Enum.sort()

    assert [:b, :c] ==
             [clock2, clock3]
             |> Clock.append_clock(clock1)
             |> Clock.clockset_replicas()
             |> Enum.sort()
  end
end

ExUnit.run()
```

### Lattices

è€ƒè™‘å¦‚ä¸‹ä¾‹å­ï¼š

1. A å’Œ B åˆå§‹å€¼éƒ½æ˜¯ `[1]`
2. A å’Œ B æ–­å¼€è¿æ¥
3. A æ·»åŠ ä¸€ä¸ªå…ƒç´  `2` -> `[1, 2]`
4. B æ·»åŠ ä¸€ä¸ªå…ƒç´  `3` -> `[1, 3]`
5. A å’Œ B é‡æ–°è¿æ¥

å¾ˆæ˜æ˜¾åˆå¹¶åçš„çŠ¶æ€æ—¶ `[1, 2, 3]`ï¼Œä½¿ç”¨æ•°å­¦è¡¨è¾¾å«[æ ¼](https://zh.wikipedia.org/wiki/æ ¼_(æ•°å­¦))ã€‚
![lattice](https://upload.wikimedia.org/wikipedia/commons/e/ea/Hasse_diagram_of_powerset_of_3.svg)

è¿™é‡Œå¤§å®¶å·²ç»æ³¨æ„åˆ°äº†å’Œå‰é¢çš„ `Vector Clock` ä¸€æ ·ï¼Œå¹¶ä¸æ˜¯ä»»æ„ä¸¤ä¸ªå€¼ä¹‹é—´éƒ½èƒ½æ¯”è¾ƒå¤§å°ï¼Œå› ä¸ºé™¤äº†å¤§äºå°äºç­‰äºå¤–ï¼Œè¿˜å­˜åœ¨ä¸€ç§ä¸ç¡®å®šçš„çŠ¶æ€ã€‚
ä½† CRDTss å¹¶ä¸å…³å¿ƒè¿™ç§ä¸ç¡®å®šçŠ¶æ€ï¼Œå› ä¸º CRDTs åªå…è®¸å•è°ƒçš„æ›´æ–°ï¼Œä¹Ÿå°±æ˜¯è¯´ä»»ä½•æ“ä½œåªä¼šè®©æ•°æ®â€œè¶Šæ¥è¶Šå¤§â€ã€‚
è¿™ä¸ªâ€œå˜å¤§â€çš„è¿‡ç¨‹å°±æ˜¯åœ¨ç¡®å®š[`ä¸Šç¡®ç•Œ`](https://zh.wikipedia.org/wiki/æœ€å°ä¸Šç•Œ)ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸ªååºé›†åˆ `M`ï¼ŒåŒ…å«å…ƒç´  `aï¼Œb ...`ã€‚å¦‚æœä¸€ä¸ªå€¼ `c` æ»¡è¶³ `a <= c` ä¸” `b <= c`ï¼Œå¹¶ä¸”æ²¡æœ‰ä»»ä½•å…¶ä»–çš„å…ƒç´ æ¯” `c` æ¥è¿‘ `a` å’Œ `b`ï¼Œ
é‚£ä¹ˆæˆ‘ä»¬å°±å« `c` æ˜¯ `a` å’Œ `b` çš„ä¸Šç¡®ç•Œã€‚

1. `c` å±äº `M`ï¼Œä¸”
2. `a <= c`ï¼Œä¸”
3. `b <= c`ï¼Œä¸”
4. å¯¹äºæ‰€æœ‰ `M` ä¸­çš„ `d`ï¼š
   1. å¦‚æœ `a <= d` ä¸” `b <= d`
   2. åˆ™ `c <= d`

ğŸŒ° è‡ªç„¶æ•°é›†åˆï¼Œä»¤ `a = 2`ï¼Œ`b = 3`ï¼Œå¦‚æœ `c = 5` æ—¶ï¼Œä¸æ»¡è¶³ä¸Šè¿°å®šä¹‰ã€‚

### Growing-only Set(GSet)

* åªèƒ½æ·»åŠ æ–°çš„å…ƒç´ 
* ä¸èƒ½åˆ é™¤å…ƒç´ 

ğŸŒ° æŠ•ç¥¨ç³»ç»Ÿï¼Œåˆ¤æ–­ä¸€ä¸ªäººæ˜¯å¦å‚ä¼šï¼ŒåŒæ—¶å¯ä»¥ä½¿ç”¨ä¸€ä¸ª `GCounter` æ¥ç»Ÿè®¡ç¥¨æ•°ï¼ˆåŒæ—¶ä¿è¯åŒ¿åæ€§ï¼‰

### 2-Phase Set

å†…éƒ¨ç”±ä¸¤ä¸ª `GSet` å®ç°ï¼Œä¸€ä¸ªç”¨äºå¢åŠ ï¼Œä¸€ä¸ªç”¨æˆ·åˆ é™¤ï¼ˆ`tombstones`ï¼‰

* å¯ä»¥æ·»åŠ å’Œåˆ é™¤
* ä½†æ˜¯å½“å…ƒç´ åˆ é™¤æ—¶ï¼Œ`tombstones GSet` ä¼šæ— é™å¢é•¿
* å½“æ·»åŠ ä¸€ä¸ªå·²ç»è¢«åˆ é™¤çš„å…ƒç´ æ—¶ï¼Œç”±äºå¹¶æ²¡æœ‰å®ç°ä» GSet ä¸­åˆ é™¤å…ƒç´ çš„æ–¹æ³•ï¼Œæ‰€ä»¥ä¸€æ—¦å…ƒç´ è¢«åˆ é™¤å°±æ°¸è¿œå­˜å‚¨åœ¨ `tombstones GSet` ä¸­

### Observed Remove Setï¼ˆORSSet)

* å¯ä»¥æ·»åŠ å’Œåˆ é™¤
* å½“å…ƒç´ è¢«åˆ é™¤æ—¶ä¾ç„¶æœ‰ `tombstones` æ— é™å¢é•¿çš„é—®é¢˜

ä½¿ç”¨é”®å€¼å¯¹å­˜å‚¨ `{element, timestamp}`ï¼Œé”®ä¸ºå…ƒç´ ï¼Œå€¼ä¸ºå…¶æœ€åä¸€æ¬¡æ·»åŠ æˆ–åˆ é™¤çš„æ—¶é—´ã€‚å½“åˆå¹¶çš„æ—¶å€™æˆ‘ä»¬æ ¹æ®æ›´æ–°æ—¶é—´ï¼Œä»¥è¾ƒå¤§çš„æ›´æ–°æ—¶é—´çš„å€¼ä¸ºå‡†ã€‚
è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Datetime` æ¥è¡¨ç¤º timestampï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸Šé¢è®²åˆ°çš„ `Vector Clock` æ¥è¡¨ç¤ºã€‚
å½“æ–°å¢å’Œåˆ é™¤å†²çªæ—¶ï¼Œé€šå¸¸æˆ‘ä»¬ä»¥æ–°å¢ä¸ºå‡†ï¼Œå³ï¼šAdd-Wins Observed Remove Setã€‚

## Phoenix.Presence

> Phoenix Presence is a feature which allows you to register process information
> on a topic and replicate it transparently across a cluster.

1. no single point of failure
2. no single source of truth
3. relies entirely on the standard library with no operational dependencies
4. self heals

ğŸŒ° è·å–å½“å‰åœ¨çº¿çš„ç”¨æˆ·

![](images/phoenix-presence.png)

### Observe Remove Set Without Tombstones(ORSWOT)

* å¯ä»¥æ·»åŠ å’Œåˆ é™¤ï¼Œä¸”ä¸å­˜åœ¨ tombstones
* å¯¹äºåŒä¸€ä¸ªå…ƒç´ çš„å¹¶å‘æ–°å¢å’Œåˆ é™¤ï¼Œä»¥æ–°å¢ä¸ºå‡† -> add-wins

**Version Vectors:**

`A = [{a, 3}, {b, 2}, {c, 1}]`ï¼š`Actor a` æœ‰ 3 æ¬¡æ›´æ–°ï¼Œ`Actor b` æœ‰ 2 æ¬¡æ›´æ–°ï¼Œ`Actor c` æœ‰ 1 æ¬¡æ›´æ–°ã€‚

<!-- livebook:{"force_markdown":true} -->

```elixir
# æ¯”è¾ƒ
[{a, 3}, {b, 2}, {c, 1}] === [{a, 3}, {b, 2}, {c, 1}]
[{a, 3}, {b, 2}, {c, 1}] > [{a, 2}, {b, 2}, {c, 1}]
[{a, 1}] > []
# partial ordering
[{a, 1}] >= []


# åˆå¹¶
A   = [{a, 1}]
B   =         [{b, 1}]
AB  = [{a, 1}, {b, 1}]
```

**ORSWOT æ•°æ®ç»“æ„:**

<!-- livebook:{"force_markdown":true} -->

```elixir
{version_verctor, entries}

entry = {element, version_vector}

orswot = {[{x, 1}, {y, 2}, [{"data1", [{x, 1}]}, {"data2", [{y, 1}]}]]}
```

**Adding an element**

* å¢åŠ  ORSWOT ä¸­çš„ version_vectorï¼Œå¦‚æœä¸å­˜åœ¨åˆ™å­˜å‚¨ä¸º 1
* æ›´æ–°çš„ `{actor, counter}` å­˜å‚¨åœ¨ entries é‡Œé¢ï¼Œå¦‚æœå­˜åœ¨åˆ™è¦†ç›–

`actor_y` å°† "data2" æ·»åŠ è¿› `{[{x, 1}], [{"data1", [{x, 1}]}]}` ä¸­ç­‰äºï¼š
`{ [ {x,1}, {y,1} ] , [ {â€œData1â€, [ {x,1} ] }, {â€œData2â€, [ {y,1} ] } ] }`

**Removing an element**

* ORSWOT ä¸­çš„ version_vector ä¸å˜
* å°† element entryentry ç›´æ¥ä» ORSWOT çš„ entries ä¸­ç§»é™¤ï¼ˆä¸å­˜åœ¨ tombstonesï¼‰

ä» ORSWOT `{ [ {x,1}, {y,1} ] , [ {â€œData1â€, [ {x,1} ] }, {â€œData2â€, [ {y,1} ] } ] }` ä¸­ç§»é™¤ `data1` ç­‰äºï¼š
`{ [ {x,1}, {y,1} ] , [ {â€œData2â€, [ {y,1} ] } ] }`

**Examples:**

1. `actor x` æ·»åŠ  `data1`
2. `actor y` æ·»åŠ  `data2`
3. `actor y` æ·»åŠ  `data3`

<!-- livebook:{"force_markdown":true} -->

```elixir
A =
  {[{x, 1}, {y, 2}], [{"data1", [{x, 1}]}, {"data2", [{y, 1}]}, {"data3", [{y, 2}]}]}
```

B =

1. `actor x` æ·»åŠ  `data1`
2. `actor y` æ·»åŠ  `data2`
3. `actor z` æ·»åŠ  `data3`
4. `actor z` æ·»åŠ  `data4`
5. `actor z` ç§»é™¤ `data1`

<!-- livebook:{"force_markdown":true} -->

```elixir
B =
  { [ {x,1}, {y,1}, {z,2} ] , [ {â€œData2â€, [ {y,1} ] }, {â€œData3â€, [ {z,1} ] }, {â€œData4â€, [ {z,2} ] } ] }
```

åˆå¹¶åï¼š

<!-- livebook:{"force_markdown":true} -->

```elixir
Megered =
  { [ {x,1}, {y,2}, {z,2} ] , [ {â€œData2â€, [ {y,1} ] }, {â€œData3â€, [ {y,2}, {z,1} ] }, {â€œData4â€, [ {z,2} ] } ] }
```

åˆå¹¶è§„åˆ™ï¼š

* Version vectors for ORSWOT A and ORSWOT B merged
* Elements merged:
  * Common elements only kept if there exists a non-empty dots for them from merging (*):
    * Common dot pairs for the element in ORSWOT A and ORSWOT B
    * Dot pairs for the element only in ORSWOT A where the dot pair count is greater than any count for the same actor in ORSWOT Bâ€™s version vector
    * Dot pairs for the element only in ORSWOT B where the dot pair count is greater than any count for the same actor in ORSWOT Aâ€™s version vector
  * Elements only in ORSWOT A only kept if there exists a non-empty dots for them after:
    * Keeping only dot pairs for the element where the dot pair count is greater than any count for the same actor in ORSWOT Bâ€™s version vector
  * Elements only in ORSWOT B only kept if there exists a non-empty dots for them after:
    * Keeping only dot pairs for the element where the dot pair count is greater than any count for the same actor in ORSWOT Aâ€™s version vector

*As you might think, if there doesnâ€™t exist an appropriate actor pair/count in the version vector then the dot pair is merged/kept

![](images/merging-example.png)

## å‚è€ƒ

* [https://medium.com/@amberovsky/crdt-conflict-free-replicated-data-types-b4bfc8459d26](https://medium.com/@amberovsky/crdt-conflict-free-replicated-data-types-b4bfc8459d26)
* [https://lars.hupel.info/topics/crdt/01-intro/](https://lars.hupel.info/topics/crdt/01-intro/)
* [https://dockyard.com/blog/2016/03/25/what-makes-phoenix-presence-special-sneak-peek](https://dockyard.com/blog/2016/03/25/what-makes-phoenix-presence-special-sneak-peek)
* [https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf](https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf)
* [https://bartoszsypytkowski.com/the-state-of-a-state-based-crdts/](https://bartoszsypytkowski.com/the-state-of-a-state-based-crdts/)
* [https://riak.com/why-vector-clocks-are-easy/](https://riak.com/why-vector-clocks-are-easy/)
